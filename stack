#include <iostream>
#include <string>
using namespace std;
const int GrowsFactor = 10;
template<typename T>
class Stack {
public:
	int capacity;
	T* st = new T[capacity];
	int size;
    Stack(): size(0), capacity(0) {}
    ~Stack() {delete[] st; }
	Stack(const Stack<T> &stack)
    {
        this->size = stack.size;
        this->capacity = stack.capacity;
        delete[] this->StackOnArray;
        this->StackOnArray = new T[stack.size];
        for(int i = 0; i < stack.size; ++i)
        {
            st[i] = stack.StackOnArray[i];
        }
    }
	bool IsEmpty() {return !size;}
	T top()
    {
        if(IsEmpty())
        {
            throw runtime_error("Stack is empty");
        }
        return st[size-1];
    }
	void Resize()
    {
        if(size + 1 > capacity)
        {
            T* NewStackOnArray = new T[capacity + GrowsFactor];
            for(int i = 0; i <= size; ++i)
            {
                NewStackOnArray[i] = st[i];
            }
            capacity += GrowsFactor;
            delete[] st;
            st = NewStackOnArray;
        }
    }
	void push(T value)
    {
        Resize();
        st[size++] = value;
    }
	T pop()
    {
        if(IsEmpty())
        {
            throw runtime_error("Stack is empty");
        }

        T value = st[--size];
        return value;
    }
	void print(ostream& out)
    {
        for(int i = size-1; i >= 0; --i)
        {
            out << st[i] << '\n';
        }
    }
	Stack& operator&=(const Stack& stack)
    {
        Stack<T> new_st (stack);
        this->size = stack.size;
        this->capacity = stack.capacity;
        delete[] this->st;
        this->st = new T[stack.size];
        int temp;
        for(int i = 0; i < stack.size; ++i)
        {
            temp = stack.st[i];
            st[i] = temp;
        }
        return *this;
    }
	T& operator[](int index)
    {
        return st[index];
    }

};

template<typename T>
bool operator==(const Stack<T>& stack1, Stack<T>& stack2)
{ return (stack1.size == stack2.size); }

template<typename T>
bool operator!=(const Stack<T>& stack1, const Stack<T>& stack2)
{ return !(stack1.size == stack2.size); }

template<typename T>
bool operator<(const Stack<T>& stack1, const Stack<T>& stack2)
{ return (stack1.size < stack2.size); }

template<typename T>
bool operator<=(const Stack<T>& stack1, const Stack<T>& stack2)
{ return (stack1.size < stack2.size || stack1 == stack2); }

template<typename T>
bool operator>(const Stack<T>& stack1, const Stack<T>& stack2)
{ return (stack1.size > stack2.size); }

template<typename T>
bool operator>=(const Stack<T>& stack1, const Stack<T>& stack2)
{ return (stack1.size > stack2.size || stack1 == stack2); }

template<typename T>
void operator<<(Stack<T>& stack, T value) { stack.push(value); }

template<typename T>
T operator>>(Stack<T>& stack, T value)
{
	value = stack.pop();
	return value;
}
int main()
{
    Stack<int> st;
    Stack<int> stack;
    st << 4;
    st << 7;
    st << 8;
    st << 9;
    st << 88;
    st << 4;
    st << 4;
    st << 7;
    st << 8;
    st << 9;
    st << 88;
    stack = st;
    st.print(std::cout);
    std::cout << std::endl;
    std::cout << (st == stack) << std::endl;
    std::cout << (st != stack) << std::endl;
    std::cout << std::endl;
    stack.print(std::cout);
}
